# 📝 알고리즘 문제 풀이 - 2025-03-25

## 문제 📖

- **문제 링크:** [백준 - 01타일](https://www.acmicpc.net/problem/1904)

- **문제 유형:** 다이나믹 프로그래밍(Dynamic Programming)

- **난이도:** Silver.3

- **풀이 시간:** ⏳ 1시간 - 실제 걸렸던 시간

## ✍ 접근 방식

- 특수 케이스 처리
	- N이 1인 경우, 가능한 수열은 “1” 하나뿐이므로 바로 1을 출력.
	- N이 2인 경우, 가능한 수열은 “11”과 “00”으로 2가지이므로 2를 출력.
- 동적 계획법 (DP) 접근
	- 타일을 놓는 방식에 따라 f(n) = f(n-1) + f(n-2) (피보나치 수열과 유사)로 표현 가능.
	- prev는 f(1), curr는 f(2)를 저장.
	- 반복문에서는 i=3부터 N까지, 다음 값 next를 (prev + curr) % MOD로 계산, prev와 curr를 순차적으로 업데이트.
- 중간 값의 크기 관리:
  - next = (prev + curr) % MOD;
    - 매 반복마다 덧셈 결과를 MOD로 나눈 나머지를 저장.
    - 이렇게 하면 중간에 계산되는 값들이 항상 MOD보다 작은 범위 내에 머무르기 때문에, 값이 너무 커지는 것을 방지.
	- next = prev + curr; 후 마지막에 curr % MOD
    - 이 경우, 중간에 계산되는 값들이 매우 커질 가능성.
    - 자바스크립트 Number 타입은 정밀도 제한(안전 정수 범위, 약 2^53)이 있기 때문에, 값이 너무 커지면 정밀도 문제가 발생 가능성.
- 정확한 모듈로 연산:
	- 모듈로 연산은 덧셈에 대해 분배 법칙이 성립하므로, (a + b) % MOD = ((a % MOD) + (b % MOD)) % MOD
  - 중간마다 모듈로 연산을 적용하면, 최종 결과에도 동일한 모듈로 값이 유지.
	- 중간 계산에서 모듈로를 적용하지 않으면, 중간 값이 안전 정수 범위를 넘어 잘못된 값이 될 수 있고, 결국 최종 결과가 틀어질 가능성.
- 메모리와 성능 측면:
	- 중간에 큰 수가 계속 누적되면 계산 속도와 메모리 사용에도 영향.
